# Документация

## Использование программы

Программа просит ввести длину и ширину лабиринта у пользователя, 
затем нужно ввести начальную и конечную точку А и B соответственно, по которым будет вестись поиск наикратчайшего пути.

После этого программа в консоль выводит лабиринт, затем лабиринт с найденным кратчайшим путем.

## Используемые алгоритмы

### Алгоритмы поиска пути
- [BfsMazeSolver](./src/main/java/backend/academy/BfsMazeSolver.java) - алгоритм поиска пути по алгоритму breadth
first search(поиск в ширину). Изначально циклом все длины клеток лабиринта помечаются -1(как непосещенные). Далее мы рандомным
образом выбираем начальную клетку и помещаем в структуру данных Queue(очередь). Далее мы выбираем клетки, в которые мы можем перейти
из начальной клетки(где между начальной клеткой и соседней нет стенки, и соседняя клетка является непосещенной). Циклом обновляем дистанцию доступных
клеток от начальной клетки(предыдущая клетка +1) и добавляем доступные клетки в очередь. Так мы проделываем пока или мы не дойдем до конечной клетки, или пока не закончатся элементы в очереди.
- [SwampMazeSolver](./src/main/java/backend/academy/SwampMazeSolver.java) - алгоритм поиска пути, который учитывает клетки болота в лабиринте. Работает
по алгоритму Дейкстры. Изначально циклом все длины клеток лабиринта помечаются Integer.MAX_VALUE(как непосещенные). Также создается двумерный массив prev,
который хранит предыдущие ячейки для восстановления пути. Создается структура данных PriorityQueue(очередь с приоритетом), где внутренний класс
CellDistance хранит ячейку и расстояние до нее. Начальная ячейка добавляется в очередь с расстоянием 0. Пока очередь не пуста, извлекается элемент с минимальным расстоянием currentCell.
Для каждой соседней ячейки, в которую можно пройти(между текущей и соседней клеткой нет стены) определяется расстояние.
Если новое расстояние меньше, чем то, которое записано сейчас, обновляется расстояние, и соседняя клетка добавляется в очередь.
Так мы проделываем пока или мы не дойдем до конечной клетки, или пока не закончатся элементы в очереди.

### Алгоритмы генерации лабиринта
- [PrimMazeGenerator](./src/main/java/backend/academy/PrimMazeGenerator.java) - алгоритм генерации лабиринта методом Прима. Изначально у всех клеток в лабиринте есть все стены.
Рандомно выбирается первая клетка, вместе с ее соседями формируются ребра, которые помещаются в структуру данных ArrayList(лист). 
После этого из листа извлекается рандомное ребро, в котором между клетками убирается стенка. Дальше алгоритм повторяется для следующей клетки. Выполнение алгоритма
заканчивается, когда ArrayList становится пустым. После этого, в зависимости от размеров лабиринта, рандомно выбираются клетки, в которых будет болото.
- [EllerMazeGenerator](./src/main/java/backend/academy/EllerMazeGenerator.java) - алгоритм генерации лабиринта методом Эллера. Изначально каждая ячейка первой строки получает свою уникальную группу.
Далее алгоритм проходится по строке и принимает решение: ставить между стенками стену или нет. Если ячейки принадлежат одной группе, то стена ставится,
если нет, то стенка ставится рандомно. Если стена удаляется, то ячейки объединяются в одну группу. Далее для этой же строки принимается решение о постановке стенки снизу.
Для каждой группы рандомным образом выбираются ячейки, которые будут соединены со строкой снизу. Если в группе только одна ячейка, то обязательно не ставится стенка. Далее вся строка копируется,
и переносится на строку ниже, где ячейки, имеющие проход снизу, получают новую группу. Процесс повторяется, пока не будут заполнены все строки по выбранной высоте лабиринта.


